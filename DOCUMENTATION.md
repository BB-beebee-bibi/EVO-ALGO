# Progrémon Project Documentation Hub

## Project Overview

The Progrémon project is an advanced evolutionary computing framework designed to automatically generate specialized programs (Progrémons) through guided evolution. At its core is the Trisolaris evolutionary engine, a sophisticated system that applies natural selection principles to iteratively improve code, configurations, and designs.

Originally developed under the directory name EVO-ALGO, the project has evolved into a modular, task-based architecture that separates the evolutionary engine (Trisolaris) from the specific tasks it can evolve solutions for. This separation allows for greater flexibility and extensibility, enabling the framework to tackle a wide range of programming challenges.

The Progrémon project represents a significant step toward autonomous program evolution guided by clearly defined constraints and objectives. It combines cutting-edge evolutionary algorithms with strict ethical boundaries and resource-aware execution to create practical, efficient, and safe software solutions.

## Component Architecture

### Trisolaris Evolutionary Engine

Trisolaris is the core evolutionary computation framework that powers the Progrémon project. Named as a reference to the science fiction novel "The Three-Body Problem" by Liu Cixin, it implements sophisticated evolutionary algorithms to generate, evaluate, and refine code solutions.

The Trisolaris engine consists of several key components:

1. **Adaptive Landscape Navigator**: Models fitness landscapes for code evolution, allowing visualization and efficient traversal of the solution space. Implements mathematical models from evolutionary theory to guide the search process.

2. **Genome Repository**: Provides versioned storage of code genomes using Git integration, with phylogenetic tracking of solution lineages. Maintains archives of both successful and failed variants.

3. **Ethical Boundary Enforcer**: Implements hard filters for static analysis before fitness evaluation. Enforces inviolable principles as constraints, not just preferences.

4. **Island Ecosystem Manager**: Maintains multiple subpopulations with different selection pressures and enables cross-pollination between islands.

5. **Resource Steward**: Monitors system resources and maintains ≥25% availability, dynamically adjusting evolution pace based on resource availability.

6. **Diversity Guardian**: Tracks population metrics and implements strategies to maintain genetic diversity.

7. **Evolution Monitor & Visualizer**: Provides tools for tracking evolution progress and visualizing results.

8. **Task Interface**: Defines a generic interface for evolvable tasks.

### Progrémon Programs

Progrémons are the specialized programs generated by the Trisolaris evolutionary engine. Each Progrémon is evolved to perform a specific task, optimized through generations of selection and refinement. The current implementation includes several types of Progrémons:

1. **Drive Scanner Progrémon**: Scans connected storage devices, creates detailed snapshots of drive contents, and identifies file types and organizes information.

2. **Network Scanner Progrémon**: Scans local networks for connected devices, identifies device types including IoT devices, and reports detailed information about discovered devices.

3. **Bluetooth Scanner Progrémon**: Scans for Bluetooth devices with a focus on security vulnerability detection.

## Theoretical Foundations

The Trisolaris framework implements key concepts from evolutionary theory:

1. **Fitness Landscapes and Adaptive Walks**: Mathematical models that represent the relationship between genotypes (code structures) and their fitness (performance). The framework navigates these landscapes to find optimal solutions.

2. **Selection Gradients and Differential Reproduction**: Mechanisms that favor the reproduction of higher-fitness solutions, gradually improving the population over generations.

3. **Mutation-Selection Balance**: The equilibrium between introducing variation through mutations and removing harmful variations through selection.

4. **Exploration-Exploitation Trade-offs**: Balancing the search for new, potentially better solutions (exploration) with refining existing good solutions (exploitation).

5. **Population Genetics Principles**: Concepts from biological evolution applied to code evolution, including genetic drift, gene flow between islands, and selection pressure.

The framework operates on three fundamental priorities:

1. **Alignment (60%)**: Solutions must adhere to universal principles including:
   - Service to others rather than self-interest
   - Truthful and transparent design
   - Resource harmony and mindfulness
   - Inclusive and respectful language
   - Humble, simple approaches over complexity

2. **Functionality (25%)**: Code must work correctly, satisfying all requirements and test cases.

3. **Efficiency (15%)**: Solutions should minimize resource usage, execution time, and complexity.

## Ethical Boundaries

The Trisolaris framework places a strong emphasis on ethical boundaries in evolved code. The Ethical Boundary Enforcer component implements hard constraints that all solutions must satisfy before they can be evaluated for fitness.

Key ethical boundaries include:

1. **Safety First**: Evolve code within strict ethical boundaries to prevent harmful operations.
2. **Resource Awareness**: Adapt to available system resources and maintain system responsiveness.
3. **Privacy Protection**: Prevent access to sensitive information and ensure data protection.
4. **Security Focus**: Block potentially malicious operations and enforce secure coding practices.
5. **Inclusive Design**: Ensure solutions are accessible and respectful to all users.

The ethical filter can be configured at different levels:

- **None**: No ethical filtering (not recommended for production)
- **Basic**: Essential safety and security checks
- **Full**: Comprehensive ethical boundary enforcement

The ethical boundaries are inspired by Gurbani principles, emphasizing service to others, truthfulness, and resource harmony.

## Task System

The Progrémon project implements a task-based architecture that separates the evolution process from specific tasks:

1. **Task Interface**: Defines a common interface that all evolvable tasks must implement, including:
   - `get_name()`: Return the task name
   - `get_description()`: Return a description of the task
   - `get_template()`: Return template code to start from
   - `evaluate_fitness()`: Evaluate the fitness of a solution

2. **Task Implementations**: Task-specific code that handles fitness evaluation, templates, and evolution parameters.

3. **Task Runner**: Generic evolution runner that can evolve any task that implements the TaskInterface.

This separation allows for:
- Reusing the same evolutionary engine for different tasks
- Defining task-specific fitness functions and templates
- Applying task-specific post-processing to evolved solutions
- Evolving new tasks without modifying the core engine

## Debug and Testing Infrastructure

The Progrémon project includes comprehensive debug utilities to help with debugging, performance monitoring, and troubleshooting:

### Debug Components

1. **Debug Logging Module**: A comprehensive debug logging module that provides multi-level logging, function call tracing with performance metrics, genome content logging, fitness evaluation details, ethical boundary check results, resource usage monitoring, evolution progress tracking, and thread-safe logging for concurrent operations.

2. **Debug Task Runner**: An enhanced version of the standard task runner with comprehensive debug logging, performance monitoring and reporting, detailed progress tracking, exception handling and reporting, and resource usage monitoring.

3. **Task-Specific Debug Scripts**: Convenience scripts for running specific tasks with debug capabilities.

### Testing Infrastructure

The project includes a testing framework with:

1. **Unit Tests**: Tests for individual components of the Trisolaris engine.
2. **Integration Tests**: Tests for the interaction between components.
3. **Functional Tests**: Tests for complete task evolution processes.

## Getting Started Guide

### Running a Task Evolution

To evolve a solution for a specific task, use the task runner:

```bash
python3 trisolaris/task_runner.py drive_scanner --template drive_scanner.py --pop-size 20 --gens 10 --ethics-level full --resource-monitoring
```

### Command-line Options

- `task`: Name of the task to evolve (e.g., drive_scanner)
- `--template`: Path to a custom template file (optional)
- `--output-dir`: Base directory to save evolved code (default: outputs)
- `--pop-size`: Population size (default: task-specific recommendation)
- `--gens`: Number of generations (default: task-specific recommendation)
- `--mutation-rate`: Mutation rate (default: task-specific recommendation)
- `--crossover-rate`: Crossover rate (default: task-specific recommendation)
- `--ethics-level`: Ethical filter level (none, basic, full) (default: basic)
- `--resource-monitoring`: Enable resource monitoring and throttling
- `--use-git`: Use Git for version control of solution history
- `--use-islands`: Use island model for evolution
- `--islands`: Number of islands when using island model (default: 3)
- `--migration-interval`: Number of generations between migrations (default: 3)
- `--diversity-threshold`: Diversity threshold for injection (default: 0.3)

### Creating a New Task

To create a new task for the Trisolaris engine:

1. Create a new class that implements the `TaskInterface` in `trisolaris/tasks/`
2. Implement all required methods
3. Register the task in `TASK_REGISTRY` in `trisolaris/task_runner.py`

### Running with Debug Capabilities

For debugging and performance monitoring, use one of the task-specific debug scripts:

```bash
# Run network scanner evolution with debug capabilities
./debug_network_scanner.py --gens=5 --pop-size=20 --debug-level=verbose

# Run drive scanner evolution with resource monitoring
./debug_drive_scanner.py --resource-monitoring --debug-level=trace

# Run bluetooth scanner evolution with island model
./debug_bluetooth_scanner.py --use-islands --islands=3 --debug-level=verbose
```

## Glossary

| Term | Definition |
|------|------------|
| **Progrémon** | A specialized program generated by the Trisolaris evolutionary engine, evolved to perform a specific task. |
| **Trisolaris** | The evolutionary computation framework that powers the Progrémon project, named after the science fiction novel "The Three-Body Problem". |
| **Adaptive Landscape** | A mathematical model that represents the relationship between code structures and their fitness or performance. |
| **Code Genome** | A representation of code as a manipulable data structure (AST or graph) that can undergo mutation and crossover operations. |
| **Ethical Boundary Enforcer** | A component that implements hard constraints that all solutions must satisfy before they can be evaluated for fitness. |
| **Fitness Evaluation** | The process of assessing how well a solution performs against defined criteria. |
| **Island Model** | An evolutionary approach that maintains multiple subpopulations with different selection pressures. |
| **Mutation** | A random change to a code genome that introduces variation. |
| **Crossover** | The process of combining parts of two parent solutions to create a new child solution. |
| **Selection Pressure** | The degree to which better-performing solutions are favored for reproduction. |
| **Task Interface** | A common interface that all evolvable tasks must implement. |
| **Resource Steward** | A component that monitors system resources and adjusts the evolution process accordingly. |
| **Diversity Guardian** | A component that tracks population metrics and implements strategies to maintain genetic diversity. |
| **Evolution Monitor** | A tool for tracking evolution progress and visualizing results. |