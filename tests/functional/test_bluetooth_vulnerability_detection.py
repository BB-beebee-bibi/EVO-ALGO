#!/usr/bin/env python3
"""
Functional tests for the enhanced Bluetooth scanner with vulnerability detection
"""
import os
import sys
import unittest
import tempfile
import json
from unittest.mock import patch, MagicMock, mock_open

# Add the parent directory to the path so we can import trisolaris modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

# Known Bluetooth vulnerabilities for testing
CVE_DATABASE = {
    "CVE-2017-0785": {
        "name": "BlueBorne SDP Information Leak",
        "description": "The BlueBorne vulnerability in SDP servers allows an attacker to get information about memory layout.",
        "affected_versions": ["Bluetooth 2.1 - 5.0"],
        "severity": "HIGH",
        "exploit_complexity": "LOW",
        "patch_available": True,
        "recommendation": "Update device firmware"
    },
    "CVE-2017-0781": {
        "name": "BlueBorne RCE Vulnerability",
        "description": "The BlueBorne vulnerability allows remote code execution over the air.",
        "affected_versions": ["Android 4.4.4 - 7.1.2", "All unpatched Linux devices with BlueZ"],
        "severity": "CRITICAL",
        "exploit_complexity": "MEDIUM",
        "patch_available": True,
        "recommendation": "Update device firmware immediately"
    },
    "CVE-2018-5383": {
        "name": "Bluetooth Pairing Key Validation",
        "description": "Vulnerability in Bluetooth Secure Simple Pairing and LE Secure Connections allows man-in-the-middle attacks.",
        "affected_versions": ["All Bluetooth BR/EDR prior to 5.1"],
        "severity": "HIGH",
        "exploit_complexity": "MEDIUM", 
        "patch_available": True,
        "recommendation": "Update to Bluetooth 5.1+ if possible"
    },
    "CVE-2019-9506": {
        "name": "KNOB Attack",
        "description": "Key Negotiation of Bluetooth (KNOB) attack allows forcing weaker encryption keys.",
        "affected_versions": ["All Bluetooth BR/EDR"],
        "severity": "HIGH",
        "exploit_complexity": "MEDIUM",
        "patch_available": True,
        "recommendation": "Apply vendor security patches"
    },
    "DEFAULT_PIN": {
        "name": "Default PIN",
        "description": "Device uses a default PIN code (like 0000, 1234) which is easily guessable.",
        "affected_versions": ["All"],
        "severity": "HIGH",
        "exploit_complexity": "LOW",
        "patch_available": True,
        "recommendation": "Change default PIN code"
    }
}


class TestBluetoothVulnerabilityDetection(unittest.TestCase):
    """Functional tests for enhanced Bluetooth vulnerability detection."""
    
    def setUp(self):
        """Set up the test environment."""
        # Create a temporary directory for output files
        self.temp_dir = tempfile.mkdtemp()
        
        # Sample Bluetooth scan output
        self.sample_scan_data = {
            "00:11:22:33:44:55": {
                "name": "LATCH Smart Lock D09",
                "address": "00:11:22:33:44:55",
                "type": "Bluetooth LE",
                "device_class": "Smart Lock",
                "rssi": -65,
                "manufacturer": "LATCH",
                "seen_time": "2023-01-01T12:00:00.000000",
                "services": ["1800", "1801", "1802", "180A", "180F", "FEED"],
                "characteristics": ["2A00", "2A01", "2A04", "2A23", "2A24", "2A25", "2A29", "2A37"]
            },
            "AA:BB:CC:DD:EE:FF": {
                "name": "Generic BT Speaker",
                "address": "AA:BB:CC:DD:EE:FF",
                "type": "Classic Bluetooth",
                "device_class": "Audio",
                "rssi": -70,
                "manufacturer": "Unknown",
                "seen_time": "2023-01-01T12:00:00.000000",
                "services": ["110b"],
                "characteristics": []
            }
        }
        
        # Mock vulnerability scan results
        self.vulnerability_scan_results = {
            "00:11:22:33:44:55": [
                {
                    "cve_id": "CVE-2018-5383",
                    "name": "Bluetooth Pairing Key Validation",
                    "severity": "HIGH",
                    "description": "Vulnerability in Bluetooth Secure Simple Pairing and LE Secure Connections allows man-in-the-middle attacks.",
                    "recommendation": "Update to Bluetooth 5.1+ if possible"
                },
                {
                    "cve_id": "DEFAULT_PIN",
                    "name": "Default PIN",
                    "severity": "HIGH",
                    "description": "Device uses a default PIN code (like 0000, 1234) which is easily guessable.",
                    "recommendation": "Change default PIN code"
                }
            ],
            "AA:BB:CC:DD:EE:FF": [
                {
                    "cve_id": "CVE-2019-9506",
                    "name": "KNOB Attack",
                    "severity": "HIGH",
                    "description": "Key Negotiation of Bluetooth (KNOB) attack allows forcing weaker encryption keys.",
                    "recommendation": "Apply vendor security patches"
                }
            ]
        }
    
    def tearDown(self):
        """Clean up test environment."""
        # Remove temporary directory
        import shutil
        shutil.rmtree(self.temp_dir)
    
    @patch('builtins.open', new_callable=mock_open)
    @patch('json.load')
    @patch('subprocess.run')
    def test_cve_database_loading(self, mock_subprocess, mock_json_load, mock_file):
        """Test that the CVE database is loaded correctly."""
        mock_json_load.return_value = CVE_DATABASE
        
        # Import the scanner code
        from trisolaris.tasks.bluetooth_scanner import BluetoothScannerTask
        
        # Get the template code
        task = BluetoothScannerTask()
        template_code = task.get_template()
        
        # Write the code to a temporary file
        scanner_path = os.path.join(self.temp_dir, "bluetooth_scanner.py")
        with open(scanner_path, "w") as f:
            f.write(template_code)
        
        # Mock run to simulate loading the CVE database
        mock_subprocess.return_value.returncode = 0
        mock_subprocess.return_value.stdout = json.dumps(CVE_DATABASE)
        
        # Execute the scanner with --check-vulnerabilities
        cmd = [sys.executable, scanner_path, "--check-vulnerabilities", "--no-scan"]
        
        # Check if the template has a load_cve_database function
        self.assertIn("load_cve_database", template_code)
        
        # Alternative approach: Check the task's required functionality
        fitness, results = task.evaluate_fitness(template_code)
        self.assertGreater(results.get("vulnerability_detection", 0), 0.3)
    
    @patch('subprocess.run')
    def test_vulnerability_scan_functionality(self, mock_subprocess):
        """Test that the vulnerability scanning functionality works correctly."""
        # Mock subprocess calls for Bluetooth scanning
        def mock_subprocess_run(*args, **kwargs):
            mock_result = MagicMock()
            mock_result.returncode = 0
            
            if args[0][0] == "python" and "bluetooth_scanner.py" in args[0][1]:
                if "--scan" in args[0]:
                    mock_result.stdout = json.dumps(self.sample_scan_data)
                elif "--check-vulnerabilities" in args[0]:
                    # Return vulnerability data for the specified device
                    if "--device" in args[0]:
                        device_index = args[0].index("--device") + 1
                        device = args[0][device_index]
                        mock_result.stdout = json.dumps(self.vulnerability_scan_results.get(device, []))
                    else:
                        # Return all vulnerability data
                        mock_result.stdout = json.dumps(self.vulnerability_scan_results)
            
            return mock_result
        
        mock_subprocess.side_effect = mock_subprocess_run
        
        # Import the scanner code
        from trisolaris.tasks.bluetooth_scanner import BluetoothScannerTask
        
        # Get the template code
        task = BluetoothScannerTask()
        
        # Evaluate fitness to test vulnerability detection
        fitness, results = task.evaluate_fitness(task.get_template())
        
        # Check that vulnerability detection is present and scores well
        self.assertGreater(results.get("vulnerability_detection", 0), 0.5)
    
    @patch('subprocess.run')
    def test_security_report_generation(self, mock_subprocess):
        """Test that security reports are generated correctly."""
        # Mock subprocess calls
        def mock_subprocess_run(*args, **kwargs):
            mock_result = MagicMock()
            mock_result.returncode = 0
            
            if "--generate-report" in args[0]:
                mock_result.stdout = json.dumps({
                    "scan_time": "2023-01-01T12:00:00.000000",
                    "devices": self.sample_scan_data,
                    "vulnerabilities": self.vulnerability_scan_results,
                    "summary": {
                        "total_devices": 2,
                        "vulnerable_devices": 2,
                        "total_vulnerabilities": 3,
                        "high_severity": 3,
                        "medium_severity": 0,
                        "low_severity": 0
                    },
                    "recommendations": [
                        "Update device firmware where possible",
                        "Change default PIN codes",
                        "Consider replacing devices with Bluetooth 5.1+ models"
                    ]
                })
            
            return mock_result
        
        mock_subprocess.side_effect = mock_subprocess_run
        
        # Import the scanner code
        from trisolaris.tasks.bluetooth_scanner import BluetoothScannerTask
        
        # Get the template code
        task = BluetoothScannerTask()
        
        # Evaluate fitness to test security reporting
        fitness, results = task.evaluate_fitness(task.get_template())
        
        # Check that security analysis is present
        self.assertGreater(results.get("security_analysis", 0), 0.5)


if __name__ == "__main__":
    unittest.main() 