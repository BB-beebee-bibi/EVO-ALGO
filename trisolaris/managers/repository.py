"""
Genome Repository for the TRISOLARIS framework.

This module implements version-controlled storage of code genomes, with support for
tracking lineages and maintaining a history of evolutionary progress.
"""

import os
import time
import json
import shutil
import logging
import subprocess
from typing import List, Dict, Optional, Any, Tuple, Set
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GenomeRepository:
    """
    Provides versioned storage of code genomes, with phylogenetic tracking of solution lineages.
    
    This class manages the storage and retrieval of genomes during the evolutionary process,
    with support for tracking lineages and maintaining historical records.
    """
    
    def __init__(
        self,
        base_dir: str = "outputs",
        run_id: Optional[str] = None,
        use_git: bool = True,
        commit_frequency: int = 10,  # Commit every 10 generations
    ):
        """
        Initialize the genome repository.
        
        Args:
            base_dir: Base directory for storing genome data
            run_id: Optional run identifier (if None, a timestamp-based ID will be generated)
            use_git: Whether to use Git for version control
            commit_frequency: How often to commit changes (in generations)
        """
        self.base_dir = base_dir
        self.run_id = run_id or f"run_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.use_git = use_git
        self.commit_frequency = commit_frequency
        
        # Full path to the run directory
        self.run_dir = os.path.join(self.base_dir, self.run_id)
        
        # Metadata storage
        self.metadata = {
            'run_id': self.run_id,
            'created_at': datetime.now().isoformat(),
            'generations': {},
            'lineages': {},
        }
        
        # Initialize directory and Git repository
        self._initialize_repository()
    
    def _initialize_repository(self):
        """Initialize the repository directory structure."""
        # Create the main run directory
        os.makedirs(self.run_dir, exist_ok=True)
        
        # Create subdirectories
        self._create_subdirs()
        
        # Initialize Git repository if enabled
        if self.use_git:
            self._init_git()
        
        # Save initial metadata
        self._save_metadata()
        
        logger.info(f"Initialized genome repository in {self.run_dir}")
    
    def _create_subdirs(self):
        """Create standard subdirectories for the repository."""
        # Directory for each generation
        os.makedirs(os.path.join(self.run_dir, "generations"), exist_ok=True)
        
        # Directory for lineage tracking
        os.makedirs(os.path.join(self.run_dir, "lineages"), exist_ok=True)
        
        # Directory for the best solutions
        os.makedirs(os.path.join(self.run_dir, "best"), exist_ok=True)
        
        # Directory for metrics and visualizations
        os.makedirs(os.path.join(self.run_dir, "metrics"), exist_ok=True)
    
    def _init_git(self):
        """Initialize Git repository for version control."""
        try:
            # Check if git is available
            result = subprocess.run(
                ["git", "--version"], 
                capture_output=True, 
                text=True
            )
            if result.returncode != 0:
                logger.warning("Git not available. Version control disabled.")
                self.use_git = False
                return
                
            # Check if it's already a git repo
            git_dir = os.path.join(self.run_dir, ".git")
            if os.path.exists(git_dir):
                logger.info("Git repository already initialized")
                return
                
            # Initialize new repo
            subprocess.run(
                ["git", "init"],
                cwd=self.run_dir,
                capture_output=True,
                text=True
            )
            
            # Create .gitignore
            with open(os.path.join(self.run_dir, ".gitignore"), "w") as f:
                f.write("# Generated by TRISOLARIS\n")
                f.write("*.pyc\n")
                f.write("__pycache__/\n")
                f.write("*.swp\n")
                f.write(".DS_Store\n")
            
            # Initial commit
            subprocess.run(
                ["git", "add", "."],
                cwd=self.run_dir,
                capture_output=True,
                text=True
            )
            subprocess.run(
                ["git", "commit", "-m", "Initial commit by TRISOLARIS"],
                cwd=self.run_dir,
                capture_output=True,
                text=True
            )
            
            logger.info("Initialized Git repository")
        except Exception as e:
            logger.warning(f"Error initializing Git repository: {str(e)}")
            self.use_git = False
    
    def _save_metadata(self):
        """Save repository metadata to disk."""
        metadata_path = os.path.join(self.run_dir, "metadata.json")
        with open(metadata_path, "w") as f:
            json.dump(self.metadata, f, indent=2)
    
    def _load_metadata(self):
        """Load repository metadata from disk."""
        metadata_path = os.path.join(self.run_dir, "metadata.json")
        if os.path.exists(metadata_path):
            with open(metadata_path, "r") as f:
                self.metadata = json.load(f)
    
    def store_solution(
        self,
        genome,
        fitness: float,
        generation: int,
        parent_ids: List[str] = None,
        metadata: Dict[str, Any] = None
    ) -> str:
        """
        Store a genome in the repository.
        
        Args:
            genome: The genome to store
            fitness: Fitness value of the genome
            generation: Generation number
            parent_ids: List of parent genome IDs (for tracking lineage)
            metadata: Additional metadata about the genome
            
        Returns:
            ID of the stored genome
        """
        # Ensure the generation directory exists
        gen_dir = os.path.join(self.run_dir, "generations", f"generation_{generation}")
        os.makedirs(gen_dir, exist_ok=True)
        
        # Generate a unique ID for this genome
        genome_id = f"genome_{generation}_{int(time.time() * 1000)}"
        
        # Make sure the genome has an ID attribute
        if hasattr(genome, 'id'):
            if not genome.id:
                genome.id = genome_id
            else:
                # Use the existing ID if it has one
                genome_id = genome.id
        
        # Store the genome's source code
        source_code = genome.to_source()
        genome_path = os.path.join(gen_dir, f"{genome_id}.py")
        with open(genome_path, "w") as f:
            f.write(source_code)
        
        # Prepare metadata
        solution_metadata = {
            'id': genome_id,
            'fitness': fitness,
            'generation': generation,
            'parent_ids': parent_ids or [],
            'created_at': datetime.now().isoformat(),
            'file_path': genome_path,
        }
        
        # Add additional metadata if provided
        if metadata:
            solution_metadata.update(metadata)
        
        # Store metadata in a companion JSON file
        metadata_path = os.path.join(gen_dir, f"{genome_id}.json")
        with open(metadata_path, "w") as f:
            json.dump(solution_metadata, f, indent=2)
        
        # Update repository metadata
        if str(generation) not in self.metadata['generations']:
            self.metadata['generations'][str(generation)] = []
        
        self.metadata['generations'][str(generation)].append(genome_id)
        
        # Update lineage metadata
        if parent_ids:
            for parent_id in parent_ids:
                if parent_id not in self.metadata['lineages']:
                    self.metadata['lineages'][parent_id] = []
                self.metadata['lineages'][parent_id].append(genome_id)
        
        # Update repository metadata file
        self._save_metadata()
        
        # If this is a "best" solution for this generation, copy to best directory
        best_dir = os.path.join(self.run_dir, "best")
        best_path = os.path.join(best_dir, f"best_gen_{generation}.py")
        
        # Check if this is the first solution for this generation, or if it's better than previous best
        is_best = False
        gen_key = str(generation)
        
        if 'best_solutions' not in self.metadata:
            self.metadata['best_solutions'] = {}
            is_best = True
        elif gen_key not in self.metadata['best_solutions']:
            is_best = True
        elif fitness > self.metadata['best_solutions'][gen_key]['fitness']:
            is_best = True
        
        if is_best:
            # Copy the file to best directory
            shutil.copy(genome_path, best_path)
            
            # Update metadata
            self.metadata['best_solutions'][gen_key] = {
                'id': genome_id,
                'fitness': fitness,
                'file_path': best_path
            }
            
            self._save_metadata()
        
        # Git commit if enabled and it's time for a commit
        if self.use_git and generation % self.commit_frequency == 0:
            try:
                subprocess.run(
                    ["git", "add", "."],
                    cwd=self.run_dir,
                    capture_output=True,
                    text=True
                )
                subprocess.run(
                    ["git", "commit", "-m", f"Generation {generation} by TRISOLARIS"],
                    cwd=self.run_dir,
                    capture_output=True,
                    text=True
                )
                logger.debug(f"Committed generation {generation} to Git")
            except Exception as e:
                logger.warning(f"Error committing to Git: {str(e)}")
        
        return genome_id
    
    def store_best_solution(self, genome, fitness: float, generation: int, metadata: Dict[str, Any] = None) -> str:
        """
        Store the best solution for a generation.
        
        Args:
            genome: The genome to store
            fitness: Fitness value of the genome
            generation: Generation number
            metadata: Additional metadata
            
        Returns:
            ID of the stored genome
        """
        # Store in regular location
        genome_id = self.store_solution(
            genome=genome,
            fitness=fitness,
            generation=generation,
            metadata=metadata
        )
        
        # Also store in best directory
        best_dir = os.path.join(self.run_dir, "best")
        best_path = os.path.join(best_dir, "best.py")
        
        # Get the source code
        source_code = genome.to_source()
        
        # Write to file
        with open(best_path, "w") as f:
            f.write(source_code)
        
        # Update metadata
        if 'overall_best' not in self.metadata:
            self.metadata['overall_best'] = {
                'id': genome_id,
                'fitness': fitness,
                'generation': generation,
                'file_path': best_path
            }
        elif fitness > self.metadata['overall_best']['fitness']:
            self.metadata['overall_best'] = {
                'id': genome_id,
                'fitness': fitness,
                'generation': generation,
                'file_path': best_path
            }
        
        self._save_metadata()
        
        return genome_id
    
    def load_solution(self, genome_id: str):
        """
        Load a genome from the repository by ID.
        
        Args:
            genome_id: ID of the genome to load
            
        Returns:
            The loaded genome
        """
        # First, find the genome file
        for gen_dir in os.listdir(os.path.join(self.run_dir, "generations")):
            dir_path = os.path.join(self.run_dir, "generations", gen_dir)
            if os.path.isdir(dir_path):
                genome_path = os.path.join(dir_path, f"{genome_id}.py")
                if os.path.exists(genome_path):
                    # Found it, load the genome
                    from trisolaris.core.genome import CodeGenome
                    with open(genome_path, "r") as f:
                        source = f.read()
                    return CodeGenome.from_source(source, genome_id=genome_id)
        
        logger.error(f"Genome not found: {genome_id}")
        return None
    
    def load_best_solution(self, generation: Optional[int] = None):
        """
        Load the best solution.
        
        Args:
            generation: Specific generation to load from (None for overall best)
            
        Returns:
            The best genome
        """
        from trisolaris.core.genome import CodeGenome
        
        if generation is not None:
            # Load best from specific generation
            best_path = os.path.join(self.run_dir, "best", f"best_gen_{generation}.py")
            if os.path.exists(best_path):
                with open(best_path, "r") as f:
                    source = f.read()
                return CodeGenome.from_source(source)
            else:
                logger.error(f"Best solution for generation {generation} not found")
                return None
        else:
            # Load overall best
            best_path = os.path.join(self.run_dir, "best", "best.py")
            if os.path.exists(best_path):
                with open(best_path, "r") as f:
                    source = f.read()
                return CodeGenome.from_source(source)
            else:
                logger.error("Overall best solution not found")
                return None
    
    def get_lineage(self, genome_id: str) -> List[str]:
        """
        Get the ancestors of a genome.
        
        Args:
            genome_id: ID of the genome
            
        Returns:
            List of ancestor IDs, from oldest to newest
        """
        # TODO: Implement recursive lineage tracking
        return []
    
    def get_descendants(self, genome_id: str) -> List[str]:
        """
        Get the descendants of a genome.
        
        Args:
            genome_id: ID of the genome
            
        Returns:
            List of descendant IDs
        """
        return self.metadata['lineages'].get(genome_id, [])
    
    def get_generation_solutions(self, generation: int) -> List[str]:
        """
        Get all solution IDs for a specific generation.
        
        Args:
            generation: Generation number
            
        Returns:
            List of genome IDs for that generation
        """
        return self.metadata['generations'].get(str(generation), [])
    
    def export_lineage_graph(self, output_file: str = None) -> str:
        """
        Export a graph representation of the solution lineages.
        
        Args:
            output_file: Path to save the graph (defaults to 'lineage_graph.dot')
            
        Returns:
            Path to the generated graph file
        """
        if output_file is None:
            output_file = os.path.join(self.run_dir, "lineage_graph.dot")
        
        # Generate DOT format graph
        graph = ["digraph Lineage {"]
        graph.append("  rankdir=LR;")
        graph.append("  node [shape=box, style=filled, fillcolor=lightblue];")
        
        # Add nodes and edges
        for parent_id, children in self.metadata['lineages'].items():
            for child_id in children:
                graph.append(f'  "{parent_id}" -> "{child_id}";')
        
        # Mark best solutions
        if 'best_solutions' in self.metadata:
            for gen, solution in self.metadata['best_solutions'].items():
                genome_id = solution['id']
                fitness = solution['fitness']
                graph.append(f'  "{genome_id}" [fillcolor=gold, label="{genome_id}\\nGen {gen}, Fitness: {fitness:.4f}"];')
        
        # Mark overall best
        if 'overall_best' in self.metadata:
            best_id = self.metadata['overall_best']['id']
            best_fitness = self.metadata['overall_best']['fitness']
            best_gen = self.metadata['overall_best']['generation']
            graph.append(f'  "{best_id}" [fillcolor=green, label="{best_id}\\nBest Overall, Gen {best_gen}, Fitness: {best_fitness:.4f}"];')
        
        graph.append("}")
        
        # Write to file
        with open(output_file, "w") as f:
            f.write("\n".join(graph))
        
        return output_file
    
    def get_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the repository contents.
        
        Returns:
            Dictionary with repository summary information
        """
        # Make sure metadata is up to date
        self._load_metadata()
        
        # Count generations and solutions - handle missing keys
        generations = len(self.metadata.get('generations', {}))
        total_solutions = sum(len(solutions) for solutions in self.metadata.get('generations', {}).values())
        
        # Get best solution info
        best_info = self.metadata.get('overall_best', {})
        
        return {
            'run_id': self.run_id,
            'created_at': self.metadata.get('created_at', datetime.now().isoformat()),
            'generations': generations,
            'total_solutions': total_solutions,
            'best_solution': {
                'id': best_info.get('id', 'None'),
                'fitness': best_info.get('fitness', 0.0),
                'generation': best_info.get('generation', -1),
            }
        }
    
    def __str__(self) -> str:
        """String representation of the repository."""
        summary = self.get_summary()
        return (
            f"GenomeRepository(run_id={summary['run_id']}, "
            f"generations={summary['generations']}, "
            f"solutions={summary['total_solutions']}, "
            f"best_fitness={summary['best_solution']['fitness']:.4f})"
        )
